function [S,W]=fastICA(Z,varargin)

%  
% function:
%     [S,W]=fastICA(Z,varargin)
% Parameter description......
%       Parameter name    ||   Parameter value       || Parameter description                   
%               Z                       : the observation matrix of dimension [m by T].
%         'method'    ['defl'|'symm']   : The orthogonal method used.
%                                         'defl'refer to the deflationary
%                                         method
%                                         'symm'refer to the symmetric method£¬The default value is 'symm'                                                mm'
%          'origW'                      : Input the initial weighted matrix,
%                                         if omitted, the initial
%                                         orthogonal matrix is generated by the system.
%      'NonlinFunc'    ['pow3'|         : Nonlinear functions¡£'pow3' refer to g(y)=y^3
%                       'tanh'|           'tanh' refer to g(y)=tanh(a1*y)  
%                       'gaus']           'gaus' refer to g(y)=y*exp(-y^2/2)                                                            
%              'a1'                     : The value called in Nonlinear function 'tanh',1<=a1<=2£¬The default value is 1
%              'a2'                     : The value called in Nonlinear function 'gaus'£¬The default value is 1
% 'maxNumIteration'                     : Maximum number of iterations, with a default value of 50
%       'OverValue'                     : The smaller the value that determines the end of the iteration, indicates that the W*W ' tends to be in the unit array
%                                         default value is 0.0001
%          'report'    ['on'|'off']     : Whether you need to print out program run information
%                                         ' On ' for printing, ' off ' for not printing. Default is ' on ' 
%                S                      : The signal of recovery
%                W                      : Weighted matrix of recovery signals,W=[b1,b2,...bm]
%
% Format£º
%     e.g. [S,W]=fastICA(WhitenedSig,'nonlinfunc','POW3','maxNumIteration',10) 
%     The optional parameters entered must be pairs. First the parameter name, followed by the corresponding parameter value. Note whether the input is a numeric value or a string. 
%

% ===================================================================
% Get the default value
ICNum=size(Z,1);    % The number of input signals is equal to the number of recovered signals    
method='symm';
NonlinFunc='pow3';
a1=1;
a2=1;
maxNumIteration=1000;
OverValue=0.0001;
report='on';
numSamples=size(Z,2);    % signal length

UserInputW=0;   % Determines whether the initial weighted matrix is entered by the user. Is 1, it is entered by the user.

% ===================================================================
% Get Optional parameters
if(mod(length(varargin),2)==1)
    error('Optional parameters should always go by pairs\n');
else
    for i=1:2:(length(varargin)-1)
        switch lower(varargin{i})
            case 'method'
                method=varargin{i+1}; method=lower(method);
            case 'origw'  % origW
                W=varargin{i+1}; 
                UserInputW=1;  
            case 'nonlinfunc'   % NonlinFunc
                NonlinFunc=varargin{i+1}; NonlinFunc=lower(NonlinFunc);
            case 'a1'
                a1=varargin{i+1};  
            case 'a2'
                a2=varargin{i+1};  
            case 'maxnumiteration'   % maxNumIteration
                maxNumIteration=varargin{i+1}; 
            case 'overvalue'         % OverValue
                OverValue=varargin{i+1};  
            case 'report'
                report=varargin{i+1};  report=lower(report);
            otherwise
                error(['Unrecognized parameter: ''' varargin{i} '''']);
        end
    end
end

if UserInputW == 0
    % The initial positive right matrix  is generated by the system
    W=orth(rand(ICNum)-0.5);
end

% ===================================================================
% Detect the correctness of input parameters
if ~( strcmp(report,'on') | strcmp(report,'off') )
    error(sprintf('Illegal value [ %s ] for parameter: ''report''\n', report));
end

if ~isreal(Z)
    error('Input matrix has an imaginary part.\n');
end

if ~( strcmp(method,'symm') | strcmp(method,'defl'))
    error(sprintf('Illegal value [ %s ] for parameter: ''method''\n', method));
end

if ~( strcmp(NonlinFunc,'pow3') | strcmp(NonlinFunc,'tanh')| ...
        strcmp(NonlinFunc,'gaus') | strcmp(NonlinFunc,'skew') )
    error(sprintf('Illegal value [ %s ] for parameter: ''NonlinFunc''\n', NonlinFunc));
end

if ~isnumeric(a1)
    error(sprintf('Illegal value for parameter: ''a1'',it must be number\n', a1));
end

if ~isnumeric(a2) 
    error(sprintf('Illegal value for parameter: ''a2'',it must be number\n', a2));
end

if (~isnumeric(maxNumIteration) ) |  maxNumIteration < 1 
    error(sprintf('Illegal value for parameter: ''maxNumIteration''\n', maxNumIteration));
end

if ~isnumeric(OverValue) 
    error(sprintf('Illegal value for parameter: ''OverValue'', it must be number.\n', OverValue));
end

if ( size(W,1)~=size(W,2) ) | ( ~isreal(W) ) | size(W,1)~=ICNum 
    error(sprintf('Illegal value for parameter: ''origW''\n'));
end

% ===================================================================
if strcmp(report,'on') 
    fprintf('\n=======================================\n');
    fprintf('   Information about parameters...\n');
    fprintf('=======================================\n');
    fprintf('Number of input signals: %d\n',size(Z,1));
    fprintf('Number of estimated signals: %d\n',ICNum);
    fprintf('Length of signals:%d\n',numSamples);    
    fprintf('method = %s\n',method);
    fprintf('initial W = \n');disp(W);
    fprintf('NonlinFunc = %s\n',NonlinFunc);
    fprintf('a1 = %d\n',a1);
    fprintf('a2 = %d\n',a2);
    fprintf('maxNumIteration = %d\n',maxNumIteration);
    fprintf('OverValue = %d\n',OverValue);
    fprintf('report = %s\n',report);
end

 
if strcmp(report,'on') 
    fprintf('\n=======================================\n');
    fprintf('    Starting ICA calculation ...\n'); 
    fprintf('=======================================\n');
end

% ===================================================================
% symmetric
if strcmp(method,'symm')
    if( strcmp(report,'on') )   fprintf('Using symmetric method \n'); end
    
    WOld=zeros(size(W));  
    
    %--------------------------------------------
    % Iteration of fast fixed-point ICA algorithm
    for loop=1:maxNumIteration + 1
        
        % If the number of iterations has not converged maxNumIteration times, the information is printed and the current W,S value is returned.
        if loop == maxNumIteration + 1  
            fprintf('Cannot convergence even after %d steps \n',maxNumIteration);
            S=W'*Z;
            return;
        end
        
        % Symmetric 
        W=W*real(inv(W'*W)^(1/2)); 
        
        % Determine whether the conditions for recursion end are met. Here, too, the vector with the opposite direction is taken into account.
      %  minAbsCos = min(abs(diag(W'*WOld)));  
        minAbsCos = min(abs(diag(W'*WOld)));  
        
        if(strcmp(report,'on'))
            fprintf('-------------------\n');
            fprintf('Step No.%d, change in value of estimate: %.6f \n',loop,1-minAbsCos);           
        end
        
        if( 1-minAbsCos < OverValue)
            if( strcmp(report,'on') )  
                fprintf('\n=======================================\n');
                fprintf('  Convergence after %d steps\n',loop);
                fprintf('=======================================\n');
            end
            S=W'*Z;
            return;               
        end
        
        WOld=W;
        
        % Using different nonlinear functions to calculate
        switch NonlinFunc
            % pow3
            case 'pow3'
                W=(Z*((Z'*W).^3))/numSamples-3*W;   
            case 'tanh'
                hypTan=tanh(a1*Z'*W);
                W=Z*hypTan/numSamples -ones(size(W,1),1)*sum(1-hypTan.^2).*W/numSamples*a1;       
            case 'gaus'
                Y=Z'*W;
                Y2=Y.^2;
                ex=exp(-a2*Y2/2);
                gauss=Y.*ex;
                degauss=(1-a2*Y2).*ex;
                W=Z*gauss/numSamples - ones(size(W,1),1)*sum(degauss).*W/numSamples;
        end
        
    end   % Iteration End
end   % symmetric method end


% ===================================================================
% deflation Orthogonal method, each column vector of weighted matrix B is obtained one after another
if strcmp(method,'defl')
    if( strcmp(report,'on') )   fprintf('Using deflation method \n'); end
    
    B=zeros(ICNum);  
    
    % Processing the initial weighted vector
    if UserInputW==0  %
        w=rand(ICNum,1)-0.5;
    else    
        w=W(:,1);
    end
    w=w-B*B'*w;     % Orthogonal
    w=w/norm(w);    % Normalization
    wOld=zeros(size(w));   
    
    %--------------------------------------------
    for i=1:ICNum                %  the independent components of ICNum are obtained in turn
        
        % ------------------------------
        % Iteration of fast fixed-point ICA algorithm
        for loop=1:maxNumIteration+1
            w=w-B*B'*w;     % Orthogonal
            w=w/norm(w);    % Normalization
            
            if loop == maxNumIteration+1     % Exit returns when the iteration exceeds maxNumIteration
                fprintf('IC No.%d cannot converge in %d iteration.\n',i,maxNumIteration);
                S=B'*Z;
                return;
            end
            
            if norm(w-wOld) < OverValue | norm(w+wOld) < OverValue
                if( strcmp(report,'on') )  
                    fprintf('IC No.%d  ---------- Computed after %d iteration\n',i,loop-1);
                end
                B(:,i)=w;  % Saves the current W value in B
                break;
            end
            
            wOld=w;
            
            % Using different nonlinear functions to calculate
            switch NonlinFunc
                
                case 'pow3'
                    w = ( Z*( (Z'*w).^3 ) )/numSamples - 3*w;
                    
                case 'tanh'
                    hypTan = tanh(a1*Z'*w);
                    w = (Z*hypTan - a1*sum(1-hypTan.^2)'*w)/numSamples;
                    
                case 'gaus'
                    u=Z'*w;
                    u2=u.^2;
                    ex=exp(-a2*u2/2);
                    gauss=u.*ex;
                    degauss=(1-a2*u2).*ex;
                    w=(Z*gauss - sum(degauss)'*w)/numSamples;
            end
         
        end  % A column vector W Loop maxNumIteration times for B 
       
    end  % 
    
    W=B;   % The output variable of the weighted matrix is W
    S=W'*Z; % The signal of recovery
    
end % deflation method end
